on the prework, is it possible to use a sync.Cond approach without using a sync.Mutex? sync.Cond requires a Locker interface.

– this got asked and was answered in slack: 

[Alex Bozhenko](https://app.slack.com/team/U0145CFU69W) [Yesterday at 12:04 PM](https://bradfield.slack.com/archives/G01KDURS65B/p1620493451034000)  

In the mutex exercise, what does this part mean?  

> "Consider also using`sync.Cond`to improve upon a basic “spin-lock” approach."

I implemented a mutex with busywait, how do I use the[sync.Cond,](https://golang.org/pkg/sync/#Cond)  
having that it does want a mutex itself, and the code example for the Cond.Wait method uses`c.L.Lock()`before calling wait.  
My understanding is that at this point, when`Lock()`  succeeded, all the busy-waiting is already done. So looking for a hint for the right direction here. (edited) 

3 replies

---

[Elliott](https://app.slack.com/team/U92R6L361)  [2 hours ago](https://bradfield.slack.com/archives/G01KDURS65B/p1620576450034500?thread_ts=1620493451.034000&cid=G01KDURS65B)  

Ah, good question. Sorry, I know it's a bit silly, but you can create a**separate**`sync.Mutex`just for use in the`sync.Cond`. (edited) 

[Elliott](https://app.slack.com/team/U92R6L361)  [2 hours ago](https://bradfield.slack.com/archives/G01KDURS65B/p1620576582034700?thread_ts=1620493451.034000&cid=G01KDURS65B)  

You might be wondering "how could you ever have a situation where you use a mutex as part of implementing a mutex, it seems circular", it'll be more clear on Tuesday.

[Elliott](https://app.slack.com/team/U92R6L361)  [2 hours ago](https://bradfield.slack.com/archives/G01KDURS65B/p1620576595034900?thread_ts=1620493451.034000&cid=G01KDURS65B)  

But the main goal of that extra part is to get some practice using`sync.Cond`


Questions from reading through mutex.go

constants were confusing? 
- mutexLocked =  1  <<  iota  // mutex is locked. iota is 0 so the left shift sets this to 1? (double checking myself: https://stackoverflow.com/questions/57330870/logical-left-shift-of-0)

> Starvation mode is important to prevent pathological cases of tail latency.

- In starvation mode we switch from allowing waiters to compete for the lock, to handing the lock to the next waiting on the wait queue. 
- Tail latency is the small % of requests that take the longest in comparison to the bulk of request. So I assume that starvation mode is meant to deal with potentially terrible performance if you have a mountain of goroutines contending for the same mutex? 

Don't really get what runtime_doSpin is doing. 

- It calls proc.sync\_runtime\_doSpin, which calls procyield for 30 spin counts. I assume that's telling the scheduler to ignore this goroutine for 30 cycles. Found this issue and it looks like it might boil down to a architecture instruction. https://github.com/golang/go/issues/16663

Where is the mutex's wait queue? Is it the runtime semaphore? How does that work exactly? 

- I'm going to assume that the waitqueue is the sempahore and that's just pointing to the head of the queue. 

